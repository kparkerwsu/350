# Include the pyeda functions
from pyeda.inter import *
from math import sqrt

### Note: All functions below are defined in conjunction with their first usage.
### i.e., CreateNodes is called first, so it is defined first.

## MARK: - General Functions
def IsPrime(num):
    # Specs specify that any number less than 3 is not prime
    # We know even numbers are not prime
    if num < 3 or num % 2 == 0:
        return False
    
    # We don't know, so we need to go through all odd #s to check if it is prime or not
    # Note: We only need to check up to the sqrt(num) since, assuming num is factorable,
    # one value must be < sqrt(num). We skip by 2 to skip the even values, as stated.
    # Needed to add +1 as it was considering 9 and some others prime.
    for i in range(3, int(sqrt(num)) + 1, 2):
        if num % i == 0:
            return False
    
    # We made it to the end, it is a prime
    return True
    

## MARK: - Project-Specific Functions

# Return an array of nodes from N1 to N31, inclusive
def CreateNodes():
    # Array to store all nodes
#    nodeArr = [exprvar('n{}'.format(i), i) for i in range(32)]
    nodeArr = []
    
    # append the node (generated by exprvar) to the nodeArr list
    for i in range(32):
        # Name all nodes as Ni where i is an int from 1 to 31
        # Give an index of i, so it can be used in later computions
        nodeArr.append(exprvar('n{}'.format(i), i))
    return nodeArr


# Return an array of Or operations between two nodes
# Each Or operation represent an edge in G
def CreateEdges(nodes):
    edgeArr = []
    # Loop through all nodes i and j, allowing us to check for the below condition.
    for i in range(32):
        for j in range(32):
            # if the nodes satistify the following condition, then add it to the list
            if (i + 3) % 32 == j % 32 or (i + 8) % 32 == j % 32:
                # Add the edge from Ni to Nj to the list
                edgeArr.append(Or(nodes[i], nodes[j]))
                
    # Return the edges for this graph
    return edgeArr

# Return a subset of nodes, only those of which are even
def GetEvenNodesFrom(nodes):
    # store all of the even nodes
    evenNodeArr = []
    
    # look at all nodes in the list
    for n in nodes:
        # read the index of the node
        # mod this value with 2 to determine if it even (0) or odd (1)
        if n.indices[0] % 2 == 0:
            # append the even node to the array
            evenNodeArr.append(n)
    
    return evenNodeArr
    
# Return a subset of nodes, only those of which are even
def GetPrimeNodesFrom(nodes):
    # Stores all of the prime nodes
    primeNodeArr = []
    
    # Look at all the nodes in the list
    for n in nodes:
        # Read the index of the node
        # Check this value in the func IsPrime()
        if IsPrime(n.indices[0]):
            # n is prime, so append to end
            primeNodeArr.append(n)
    
    return primeNodeArr

# This will return forumula of And(Or(...), ..., Or(...))
def GetFormulaFromEdges(edges):
    # Use the * operator on edges, an array
    # This will expand the array into arguments passed into And.
    return And(*edges)

# Return the close of RoR
def GetClosure(bdd, nodes):
##### REMOVE ######
#    return bdd.compose({nodes[i]: nodes[j] for i in range(32) for j in range(32)})

    # Arugments of composure
    composeArg = {}
    for n1 in nodes:
        for n2 in nodes:
            # At n1, set n2 - these are the nodes in the array
            composeArg[n1] = n2
    # bdd.compose() will return the compose() of the arguments above.
    return bdd.compose(composeArg)
    
    
# Get reachable nodes given a bdd
def GetReachable(bdd, nodes, reachableTo):
    # restrict statement results
    restricts = []
    # go through each node (in even)
    for n in reachableTo:
        restrictArg = {}
        for n2 in nodes:
            restrictArg[n2] = 1
        # append the restrict
        restricts.append(bdd.restrict(restrictArg))
    
    # Return and of all args in restricts
    return And(*restricts)

# Get the node at some corresponding i
# Assuming nodes is sorted
def GetNodeAt(i, nodes):
    # Go through n to search for i
    for n in nodes:
        # If the node has the same id (i), return it
        if n.indices[0] == i:
            return n
            
    # Does not exist in the list, return none
    return None


GREEN_COLOR = '\033[92m'
RED_COLOR = '\033[91m'
RESET_COLOR = '\033[0m'

# Reset the output color to the system default
# using the RESET_COLOR variable
def ResetOutputColor():
    print(RESET_COLOR, end='')

# Set the output color to red
# using the RED_COLOR variable
def SetRedOutput():
    ResetOutputColor()
    print(RED_COLOR, end='')

# Set the output color to green
# using the GREEN_COLOR variable
def SetGreenOutput():
    ResetOutputColor()
    print(GREEN_COLOR, end='')
